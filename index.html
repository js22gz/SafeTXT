<script>
const APP_CONFIG = {
    VERSION: '1.2', // Bumped for lock changes
    FILE_FORMAT_VERSION: 0x01,
    SALT_LENGTH: 16,
    IV_LENGTH: 12,
    GCM_TAG_LENGTH: 16,
    PBKDF2_ITERATIONS: 600000,
    DIGEST_THROTTLE_MS: 15000, // throttle digest hashing to reduce shared-drive I/O
    AUTO_SAVE_DELAY_MS: 1000,
    INACTIVITY_TIMEOUT_MS: 10 * 60 * 1000,
    MAX_FILE_SIZE_MB: 100, // Maximum file size in megabytes
    DB_NAME: 'LocalNote_v2026', // preserve original name so existing users keep their file handles
    DB_VERSION: 2,
    LOCK_SUFFIX: '.lock',
    LOCK_STALE_MS: 15 * 60 * 1000,    // 15 min
    LOCK_POLL_MS: 10000,              // 10 s poll for lock status
    LOCK_POLL_DEBOUNCE_MS: 500,
};
const App = {
state: {
    db: null,
    key: null,
    currentHandle: null,
    syncInProgress: false,
    lastMTime: 0,
    lastDigest: null,
    lastDigestCheck: 0,
    isDirty: false,
    decryptionFailed: false,
    baseContent: null,
    saveTimeout: null,
    // Event handlers storage for proper cleanup
    fileListClickHandler: null,
    fileListKeydownHandler: null,
    editorInputHandler: null,
    passInputKeypressHandler: null,
    sessionId: null,
    currentLockHandle: null,
    lockPollInterval: null,
},
    _toastTimer: null,
    _wipeBytes(arr) {
        if (arr instanceof Uint8Array) arr.fill(0);
    },
    _setBaseContent(bytes) {
        if (this.state.baseContent instanceof Uint8Array && this.state.baseContent !== bytes) {
            this.state.baseContent.fill(0);
        }
        this.state.baseContent = bytes;
    },
    _setReadOnlyDueToLock(readOnly, reason = '') {
        if (this.state.decryptionFailed) readOnly = true; // Override if failed decrypt
        const editor = document.getElementById('editor');
        const status = document.getElementById('save-status');
        if (readOnly) {
            editor.disabled = true;
            clearTimeout(this.state.saveTimeout);
            status.textContent = `ðŸ‘ï¸ Locked by ${reason || 'another session'} â€“ read-only`;
            this.showToast('File is locked by another session', 5000);
        } else {
            if (!this.state.decryptionFailed && this.state.key) editor.disabled = false;
            status.textContent = 'Editing enabled';
        }
    },
    async init() {
        this.setupEditorHandler();
        this.setupPassInputHandler();
        try {
            this.state.db = await new Promise((resolve, reject) => {
                const req = indexedDB.open(APP_CONFIG.DB_NAME, APP_CONFIG.DB_VERSION);
                req.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains('handles')) db.createObjectStore('handles');
                    if (e.oldVersion < 2 && !db.objectStoreNames.contains('locks')) {
                        db.createObjectStore('locks');
                    }
                };
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
            this.setupFileListHandlers();
            await this.renderList();
            this.setupServiceWorker();
        } catch (e) {
            console.error('Init failed:', e);
            this.state.db = null;
        }
    },
    setupEditorHandler() {
        this.state.editorInputHandler = () => {
            if (this.state.decryptionFailed) return;
            this.state.isDirty = true;
            document.getElementById('save-status').textContent = "â— Editing...";
            clearTimeout(this.state.saveTimeout);
            this.state.saveTimeout = setTimeout(() => this.save(), APP_CONFIG.AUTO_SAVE_DELAY_MS);
        };
        document.getElementById('editor').oninput = this.state.editorInputHandler;
    },
    setupPassInputHandler() {
        this.state.passInputKeypressHandler = (e) => {
            if (e.key === 'Enter') this.unlock();
        };
        document.getElementById('pass-input').addEventListener('keypress', this.state.passInputKeypressHandler);
    },
    setupServiceWorker() {
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('./sw.js')
                .then(() => console.log('Service Worker registered successfully'))
                .catch((error) => console.warn('Service Worker registration failed:', error));
        }
    },
    setupFileListHandlers() {
        const fileList = document.getElementById('file-list');
        // Remove old handlers if they exist to prevent duplicate listeners
        if (this.state.fileListClickHandler) {
            fileList.removeEventListener('click', this.state.fileListClickHandler);
        }
        if (this.state.fileListKeydownHandler) {
            fileList.removeEventListener('keydown', this.state.fileListKeydownHandler);
        }
        // Store handlers for later cleanup
        this.state.fileListClickHandler = (e) => {
            const removeBtn = e.target.closest('.remove-btn');
            if (removeBtn) {
                const name = removeBtn.closest('.file-item').getAttribute('data-filename');
                this.removeHandle(e, name);
                return;
            }
            const item = e.target.closest('.file-item');
            if (item && this.state.db) {
                const tx = this.state.db.transaction('handles');
                const req = tx.objectStore('handles').get(item.getAttribute('data-filename'));
                req.onsuccess = () => { if (req.result) this.loadFile(req.result); };
            }
        };
        this.state.fileListKeydownHandler = (e) => {
            const item = e.target.closest('.file-item');
            if (!item || !this.state.db) return;
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                const tx = this.state.db.transaction('handles');
                const req = tx.objectStore('handles').get(item.getAttribute('data-filename'));
                req.onsuccess = () => { if (req.result) this.loadFile(req.result); };
            } else if (e.key === 'Delete' || e.key === 'Backspace') {
                e.preventDefault();
                this.removeHandle(e, item.getAttribute('data-filename'));
            }
        };
        fileList.addEventListener('click', this.state.fileListClickHandler);
        fileList.addEventListener('keydown', this.state.fileListKeydownHandler);
    },
    cleanupFileListHandlers() {
        const fileList = document.getElementById('file-list');
        if (!fileList) return;
        
        if (this.state.fileListClickHandler) {
            fileList.removeEventListener('click', this.state.fileListClickHandler);
            this.state.fileListClickHandler = null;
        }
        if (this.state.fileListKeydownHandler) {
            fileList.removeEventListener('keydown', this.state.fileListKeydownHandler);
            this.state.fileListKeydownHandler = null;
        }
    },
    // --- INACTIVITY TIMER ---
    inactivityManager: {
        INACTIVITY_THRESHOLD: APP_CONFIG.INACTIVITY_TIMEOUT_MS,
        WARNING_SECONDS: 30,
        inactivityTimer: null,
        warningTimer: null,
        warningCountdown: null,
        eventListeners: [],
        init() {
            const events = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click'];
            const handler = () => this.resetTimer();
            events.forEach(evt => {
                document.addEventListener(evt, handler, true);
                this.eventListeners.push({ event: evt, handler });
            });
            this.resetTimer();
        },
        resetTimer() {
            clearTimeout(this.inactivityTimer);
            clearTimeout(this.warningTimer);
            clearInterval(this.warningCountdown);
            this.hideWarning();
            this.inactivityTimer = setTimeout(() => this.showWarning(),
                this.INACTIVITY_THRESHOLD - this.WARNING_SECONDS * 1000);
            this.warningTimer = setTimeout(() => this.lockSession(),
                this.INACTIVITY_THRESHOLD);
        },
        showWarning() {
            const el = document.getElementById('inactivity-warning');
            el.classList.remove('hidden');
            let seconds = this.WARNING_SECONDS;
            this.warningCountdown = setInterval(() => {
                seconds--;
                const m = Math.floor(seconds / 60);
                const s = seconds % 60;
                document.getElementById('inactivity-timer').textContent = `${m}:${s.toString().padStart(2, '0')}`;
                if (seconds <= 0) clearInterval(this.warningCountdown);
            }, 1000);
        },
        hideWarning() {
            document.getElementById('inactivity-warning').classList.add('hidden');
            clearInterval(this.warningCountdown);
        },
        lockSession() {
            this.hideWarning();
            App.lock(true);
        },
        cleanup() {
            clearTimeout(this.inactivityTimer);
            clearTimeout(this.warningTimer);
            clearInterval(this.warningCountdown);
            this.hideWarning();
            // Remove event listeners to prevent memory leak
            this.eventListeners.forEach(({ event, handler }) => {
                document.removeEventListener(event, handler, true);
            });
            this.eventListeners = [];
        }
    },
    // --- SESSION CONTROL ---
    async unlock() {
        const inputEl = document.getElementById('pass-input');
        const pass = inputEl.value;
        
        if (!pass || pass.length < 12) {
            alert("Password must be at least 12 characters for security.");
            return;
        }
        
        // Encode password to Uint8Array so we can wipe it after use
        const passBytes = new TextEncoder().encode(pass);
        
        try {
            this.state.key = await crypto.subtle.importKey(
                "raw", passBytes, "PBKDF2", false, ["deriveKey"]
            );
            
            passBytes.fill(0);
            inputEl.value = "";
            document.getElementById('unlock-overlay').classList.add('hidden');
            document.getElementById('app-shell').classList.remove('blur');
            document.getElementById('editor').disabled = false;
            document.getElementById('save-status').textContent = "Session Active";
            this.updateSaveButtonLabel();
            this.inactivityManager.init();
            this.state.sessionId = crypto.randomUUID();
        } catch (e) {
            passBytes.fill(0);
            console.error('Unlock failed:', e);
            alert('Failed to initialize session. Please try again.');
            this.state.key = null;
        }
    },
    async lock(force = false) {
        if (!force && !confirm("Lock session? You will need to re-enter your key to view notes.")) return;
        clearTimeout(this.state.saveTimeout);
        this.inactivityManager.cleanup();
        // Clean up event listeners to prevent memory leaks
        this.cleanupFileListHandlers();
        
        await this.releaseCurrentLock();
        this.teardownLockPoller();
        
        // Remove editor input handler
        const editor = document.getElementById('editor');
        if (editor) {
            editor.oninput = null;
        }
        
        // Remove password input keypress handler
        const passInput = document.getElementById('pass-input');
        if (this.state.passInputKeypressHandler && passInput) {
            passInput.removeEventListener('keypress', this.state.passInputKeypressHandler);
            this.state.passInputKeypressHandler = null;
        }
        // Clear sensitive data from memory before reload.
        // Uint8Array buffers are mutable and can be wiped in-place,
        // unlike JS strings which are immutable and persist until GC.
        if (editor) {
            editor.value = '';
        }
        if (passInput) {
            passInput.value = '';
        }
        
        // Wipe baseContent Uint8Array in-place before releasing
        this._setBaseContent(null);
        
        // Clear key reference (CryptoKey is opaque and not inspectable)
        this.state.key = null;
        this.state.currentHandle = null;
        this.updateSaveButtonLabel();
        this.state.isDirty = false;
        this.state.lastMTime = 0;
        this.state.lastDigest = null;
        this.state.lastDigestCheck = 0;
        if (this.state.db) { this.state.db.close(); this.state.db = null; }
        // Instruct service worker to purge cached app content with timeout
        try {
            if (navigator.serviceWorker && navigator.serviceWorker.controller) {
                navigator.serviceWorker.controller.postMessage({ type: 'CLEAR_CACHE' });
            }
        } catch (e) {
            console.warn('Failed to send clear cache message to service worker:', e);
        }
        location.reload();
    },
    togglePass() {
        const el = document.getElementById('pass-input');
        el.type = el.type === 'password' ? 'text' : 'password';
    },
    // --- CRYPTO ENGINE ---
    async deriveKeyFromSalt(salt) {
        if (!this.state.key) throw new Error("Session locked");
        if (!salt) throw new Error("Salt is required for key derivation.");
        return crypto.subtle.deriveKey(
            {
                name: "PBKDF2",
                salt,
                iterations: APP_CONFIG.PBKDF2_ITERATIONS,
                hash: "SHA-256"
            },
            this.state.key,
            { name: "AES-GCM", length: 256 },
            false,
            ["encrypt", "decrypt"]
        );
    },
        
async encrypt(plainBytes) {
        if (!this.state.key) throw new Error('Unlock session first.');
        // Always generate a fresh random salt per encryption operation
        const salt = crypto.getRandomValues(new Uint8Array(APP_CONFIG.SALT_LENGTH));
        const fileKey = await this.deriveKeyFromSalt(salt);
        const iv = crypto.getRandomValues(new Uint8Array(APP_CONFIG.IV_LENGTH));
        // Build metadata buffer [Version][Salt][IV] for GCM additional authenticated data
        const metadata = new Uint8Array(1 + salt.length + iv.length);
        metadata[0] = APP_CONFIG.FILE_FORMAT_VERSION;
        metadata.set(salt, 1);
        metadata.set(iv, 1 + salt.length);
        
        // Encrypt with additionalData to authenticate the file header
        const cipher = await crypto.subtle.encrypt(
            { name: "AES-GCM", iv, additionalData: metadata }, 
            fileKey, 
            plainBytes
        );
        // Pack the binary: [Version][Salt][IV][Cipher]
        const blob = new Uint8Array(metadata.length + cipher.byteLength);
        blob.set(metadata);
        blob.set(new Uint8Array(cipher), metadata.length);
        
        return blob;
    },
    async computeDigest(buffer) {
        const hash = await crypto.subtle.digest('SHA-256', buffer);
        return Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).join('');
    },
    // --- FILE OPERATIONS ---
    async createNote() {
        try {
            const h = await window.showSaveFilePicker({
                suggestedName: 'untitled.txt',
                types: [{ accept: {'text/plain': ['.txt']} }]
            });
            if (this.state.key) {
                const blob = await this.encrypt(new Uint8Array(0));
                const stream = await h.createWritable();
                await stream.write(blob);
                await stream.close();
            }
            await this.persistHandle(h);
            await this.loadFile(h);
            document.getElementById('save-status').textContent = "âœ“ New note created";
        } catch (e) {
            if (e.name !== 'AbortError') {
                document.getElementById('save-status').textContent = "âš ï¸ Failed to create note";
            }
        }
    },
    async importNote() {
        try {
            const [h] = await window.showOpenFilePicker();
            await this.persistHandle(h);
            await this.loadFile(h);
            document.getElementById('save-status').textContent = "âœ“ File imported";
        } catch (e) {
            if (e.name !== 'AbortError') {
                document.getElementById('save-status').textContent = "âš ï¸ Failed to import file";
            }
        }
    },
    async persistHandle(h) {
        if (!this.state.db) {
            console.error('Database not initialized');
            return;
        }
        const tx = this.state.db.transaction('handles', 'readwrite');
        await new Promise((resolve, reject) => {
            tx.onabort = () => reject(tx.error || new Error('Transaction aborted'));
            tx.onerror = () => reject(tx.error);
            const req = tx.objectStore('handles').put(h, h.name);
            req.onsuccess = () => resolve();
            req.onerror = () => reject(req.error);
        });
        await this.renderList();
    },
    async getHandlesFromDB() {
        if (!this.state.db) return [];
        return new Promise((resolve, reject) => {
            const tx = this.state.db.transaction('handles', 'readonly');
            tx.onabort = () => reject(tx.error || new Error('Transaction aborted'));
            tx.onerror = () => reject(tx.error);
            const req = tx.objectStore('handles').getAll();
            req.onsuccess = () => resolve(req.result || []);
            req.onerror = () => reject(req.error);
        });
    },
    async loadFile(h) {
        try {
            if (await h.queryPermission({mode: 'readwrite'}) !== 'granted') {
                if (await h.requestPermission({mode: 'readwrite'}) !== 'granted') {
                    document.getElementById('save-status').textContent = "âš ï¸ Permission denied";
                    return;
                }
            }
            const fileName = h.name;
            // Acquire lock (prompts only on first use per file)
            const canWrite = await this.acquireLock(h, fileName);
            this.state.currentHandle = h;
            this.updateSaveButtonLabel();
            const file = await h.getFile();
            
            // Check file size to prevent OOM
            const maxSizeBytes = APP_CONFIG.MAX_FILE_SIZE_MB * 1024 * 1024;
            if (file.size > maxSizeBytes) {
                document.getElementById('save-status').textContent = `âš ï¸ File too large (max ${APP_CONFIG.MAX_FILE_SIZE_MB}MB)`;
                alert(`File is too large (${(file.size / 1024 / 1024).toFixed(1)}MB). Maximum supported size is ${APP_CONFIG.MAX_FILE_SIZE_MB}MB.`);
                return;
            }
            
            const buffer = await file.arrayBuffer();
            const digest = await this.computeDigest(buffer);
            this.state.lastMTime = file.lastModified;
            this.state.lastDigest = digest;
            this.state.lastDigestCheck = Date.now();
            this.state.isDirty = false;
            this.state.decryptionFailed = false;
            
            const result = await this.getDecryptedText(new Uint8Array(buffer));
            const editor = document.getElementById('editor');
            if (result.success) {
                this.state.decryptionFailed = false;
                editor.value = new TextDecoder().decode(result.plainBytes);
                this._setBaseContent(result.plainBytes);
                document.getElementById('save-status').textContent = "Loaded from disk";
            } else {
                this.state.decryptionFailed = true;
                editor.value = result.errorMessage;
                this._setBaseContent(null);
                document.getElementById('save-status').textContent = "âš ï¸ Decryption failed â€” editing disabled";
            }
            this._setReadOnlyDueToLock(!canWrite);
            // Use textContent to prevent XSS
            document.getElementById('active-filename').textContent = h.name;
            await this.renderList();
            await this.setupLockPoller();
        } catch (e) {
            console.error('Error loading file:', e);
            document.getElementById('save-status').textContent = "âš ï¸ Error loading file";
            alert(`Failed to load file: ${e.message || 'Unknown error'}`);
        }
    },
    async save() {
        if (!this.state.currentHandle || !this.state.key || this.state.decryptionFailed || this.state.syncInProgress) return;
        try {
            // LOCK: Tell the observer to ignore the upcoming disk event
            this.state.syncInProgress = true; 
            const plainBytes = new TextEncoder().encode(document.getElementById('editor').value);
            const encryptedBytes = await this.encrypt(plainBytes);
            const stream = await this.state.currentHandle.createWritable();
            await stream.write(encryptedBytes);
            await stream.close();
            // Update local metadata so we know what the "latest" version looks like
            const digest = await this.computeDigest(encryptedBytes);
            const f = await this.state.currentHandle.getFile();
            this.state.lastMTime = f.lastModified;
            this.state.lastDigest = digest;
            this.state.lastDigestCheck = Date.now();
            this.state.isDirty = false;
            this._setBaseContent(plainBytes);
            
            document.getElementById('save-status').textContent = "âœ“ Encrypted & Saved";
        } catch (e) {
            console.error('Error saving file:', e);
            document.getElementById('save-status').textContent = "âš ï¸ Error Saving";
        } finally {
            // UNLOCK: Allow the observer to listen for external changes again
            // We use a small timeout to ensure the OS has finished flushing the write
            setTimeout(() => { this.state.syncInProgress = false; }, 500);
        }
    },
    
    async saveOrSaveAs() {
        if (!this.state.key) {
            document.getElementById('save-status').textContent = "âš ï¸ Session locked";
            return;
        }
        if (this.state.decryptionFailed) {
            document.getElementById('save-status').textContent = "âš ï¸ Cannot save â€” file not decrypted";
            return;
        }
        if (this.state.currentHandle) {
            // File already exists, just save
            await this.save();
        } else {
            // No file open, do Save As (create new note)
            await this.createNote();
        }
    },
    async refreshFile() {
        if (!this.state.currentHandle || !this.state.key) {
            document.getElementById('save-status').textContent = "âš ï¸ No file to refresh";
            return;
        }
        if (this.state.decryptionFailed) {
            document.getElementById('save-status').textContent = "âš ï¸ Cannot refresh â€” file not decrypted";
            return;
        }
        document.getElementById('save-status').textContent = "ðŸ”„ Refreshing from disk...";
        // Reload the file content
        const file = await this.state.currentHandle.getFile();
        const buffer = await file.arrayBuffer();
        const result = await this.getDecryptedText(new Uint8Array(buffer));
        if (result.success) {
            document.getElementById('editor').value = new TextDecoder().decode(result.plainBytes);
            this._setBaseContent(result.plainBytes);
            this.state.isDirty = false;
            document.getElementById('save-status').textContent = "âœ“ Refreshed from disk";
        } else {
            document.getElementById('save-status').textContent = "âš ï¸ Refresh failed â€” decryption error";
        }
    },
    updateSaveButtonLabel() {
        const saveBtn = document.getElementById('save-btn');
        if (saveBtn) {
            if (this.state.currentHandle) {
                saveBtn.textContent = 'ðŸ’¾ Save';
                saveBtn.setAttribute('aria-label', 'Save current file');
            } else {
                saveBtn.textContent = 'ðŸ’¾ Save As...';
                saveBtn.setAttribute('aria-label', 'Save as new file');
            }
        }
    },
    // --- LOCK HELPERS ---
    async getLockHandle(fileName) {
        if (!this.state.db) return null;
        return new Promise((resolve) => {
            const tx = this.state.db.transaction('locks', 'readonly');
            const req = tx.objectStore('locks').get(fileName);
            req.onsuccess = () => resolve(req.result || null);
            req.onerror = () => resolve(null);
        });
    },

    async persistLock(fileName, lockHandle) {
        if (!this.state.db) return;
        const tx = this.state.db.transaction('locks', 'readwrite');
        await new Promise((resolve, reject) => {
            tx.onerror = () => reject(tx.error);
            const req = tx.objectStore('locks').put(lockHandle, fileName);
            req.onsuccess = () => resolve();
        });
    },

    async deleteLockEntry(fileName) {
        if (!this.state.db) return;
        const tx = this.state.db.transaction('locks', 'readwrite');
        await new Promise((resolve) => {
            const req = tx.objectStore('locks').delete(fileName);
            req.onsuccess = () => resolve();
        });
    },

    async createLockFile(suggestedName) {
        return window.showSaveFilePicker({
            suggestedName,
            types: [{ description: 'Lock file', accept: { 'application/json': ['.lock'] } }]
        });
    },

    async writeLockData(lockHandle, data) {
        const stream = await lockHandle.createWritable();
        await stream.write(JSON.stringify(data));
        await stream.close();
    },

    async checkLockStatus(lockHandle) {
        try {
            const file = await lockHandle.getFile();
            const text = await file.text();
            const data = JSON.parse(text);
            const age = Date.now() - (data.timestamp || 0);

            if (data.released || age > APP_CONFIG.LOCK_STALE_MS) {
                return { available: true };
            }
            if (data.sessionId === this.state.sessionId) {
                return { owned: true, timestamp: data.timestamp };
            }
            return { owned: false, ownerHint: data.sessionId ? 'another session' : 'unknown' };
        } catch (e) {
            return { exists: false };
        }
    },

    async keepAliveLock(lockHandle) {
        const data = {
            sessionId: this.state.sessionId,
            timestamp: Date.now(),
            released: false
        };
        await this.writeLockData(lockHandle, data);
    },

    async releaseLock(lockHandle) {
        if (!lockHandle) return;
        try {
            const data = {
                sessionId: this.state.sessionId,
                timestamp: 0,
                released: true
            };
            await this.writeLockData(lockHandle, data);
        } catch (e) {
            console.warn('Failed to release lock (normal on abrupt close):', e);
        }
    },

    async acquireLock(fileHandle, fileName) {
        // Check stored lock first
        let lockH = await this.getLockHandle(fileName);
        if (lockH) {
            const status = await this.checkLockStatus(lockH);
            if (status.owned) {
                await this.keepAliveLock(lockH);
                this.state.currentLockHandle = lockH;
                return true; // writable
            } else if (status.available) {
                // Reclaim stale/released lock
                await this.writeLockData(lockH, {
                    sessionId: this.state.sessionId,
                    timestamp: Date.now(),
                    released: false
                });
                this.state.currentLockHandle = lockH;
                return true;
            } else {
                // Locked by other
                this.state.currentLockHandle = lockH; // Still poll it
                return false;
            }
        }

        // First-time: prompt user to create lock file in same folder
        try {
            lockH = await this.createLockFile(fileName + APP_CONFIG.LOCK_SUFFIX);
            await this.writeLockData(lockH, {
                sessionId: this.state.sessionId,
                timestamp: Date.now(),
                released: false
            });
            await this.persistLock(fileName, lockH);
            this.state.currentLockHandle = lockH;
            this.showToast('Lock file created â€“ only you can edit');
            return true;
        } catch (e) {
            if (e.name !== 'AbortError') console.error('Lock creation failed:', e);
            this._setReadOnlyDueToLock(true, 'lock creation aborted');
            return false;
        }
    },
    async releaseCurrentLock() {
        if (this.state.currentLockHandle) {
            await this.releaseLock(this.state.currentLockHandle);
            this.state.currentLockHandle = null;
        }
    },
    setupLockPoller() {
        this.teardownLockPoller();
        if (!this.state.currentLockHandle) return;
        this.state.lockPollInterval = setInterval(async () => {
            if (!this.state.currentLockHandle || this.state.syncInProgress) return;
            const status = await this.checkLockStatus(this.state.currentLockHandle);
            if (status.owned) {
                await this.keepAliveLock(this.state.currentLockHandle);
                this._setReadOnlyDueToLock(false);
            } else if (status.available) {
                // Auto-reclaim if stale during poll
                await this.writeLockData(this.state.currentLockHandle, {
                    sessionId: this.state.sessionId,
                    timestamp: Date.now(),
                    released: false
                });
                this._setReadOnlyDueToLock(false);
            } else {
                this._setReadOnlyDueToLock(true, status.ownerHint || 'another session');
                // Optional: auto-backup if dirty
                if (this.state.isDirty) {
                    await this._storeBackup(this.state.currentHandle.name, document.getElementById('editor').value);
                    this.showToast('Edits backed up â€“ file now locked remotely');
                    this.state.isDirty = false;
                }
            }
        }, APP_CONFIG.LOCK_POLL_MS);
    },

    teardownLockPoller() {
        if (this.state.lockPollInterval) {
            clearInterval(this.state.lockPollInterval);
            this.state.lockPollInterval = null;
        }
    },
    // --- DIFF / MERGE ---
    /**
     * Compute longest common subsequence length table for two arrays.
     */
    _lcsTable(a, b) {
        const m = a.length, n = b.length;
        const dp = Array.from({length: m + 1}, () => new Uint32Array(n + 1));
        for (let i = 1; i <= m; i++)
            for (let j = 1; j <= n; j++)
                dp[i][j] = a[i - 1] === b[j - 1] ? dp[i - 1][j - 1] + 1 : Math.max(dp[i - 1][j], dp[i][j - 1]);
        return dp;
    },
    /**
     * Line-based three-way merge. Returns {merged, hasConflict}.
     * base/local/remote are strings. Splits on newlines and merges.
     */
    diff3Merge(base, local, remote) {
        const bLines = base.split('\n');
        const lLines = local.split('\n');
        const rLines = remote.split('\n');
        // Build diff hunks from baseâ†’child using LCS back-trace
        const diffHunks = (base, child) => {
            const dp = this._lcsTable(base, child);
            const hunks = [];
            let i = base.length, j = child.length;
            const pairs = [];
            while (i > 0 && j > 0) {
                if (base[i - 1] === child[j - 1]) { pairs.push([i - 1, j - 1]); i--; j--; }
                else if (dp[i - 1][j] >= dp[i][j - 1]) i--;
                else j--;
            }
            pairs.reverse();
            let bi = 0, ci = 0;
            for (const [bm, cm] of pairs) {
                if (bi < bm || ci < cm) hunks.push({baseStart: bi, baseEnd: bm, childStart: ci, childEnd: cm});
                bi = bm + 1; ci = cm + 1;
            }
            if (bi < base.length || ci < child.length) hunks.push({baseStart: bi, baseEnd: base.length, childStart: ci, childEnd: child.length});
            return hunks;
        };
        const lHunks = diffHunks(bLines, lLines);
        const rHunks = diffHunks(bLines, rLines);
        // Build a map of base line ranges changed by each side
        const touchedByL = new Set();
        const touchedByR = new Set();
        for (const h of lHunks) for (let k = h.baseStart; k < h.baseEnd; k++) touchedByL.add(k);
        for (const h of rHunks) for (let k = h.baseStart; k < h.baseEnd; k++) touchedByR.add(k);
        // Check for overlapping changes (conflicts)
        let hasConflict = false;
        for (const line of touchedByL) {
            if (touchedByR.has(line)) { hasConflict = true; break; }
        }
        if (!hasConflict) {
            // Non-conflicting: apply remote hunks to local (local is our working copy)
            // Rebuild from base, preferring local changes where local changed, remote where remote changed, base otherwise
            const result = [];
            let bi = 0;
            const lMap = new Map(); // baseStart -> hunk
            const rMap = new Map();
            for (const h of lHunks) lMap.set(h.baseStart, h);
            for (const h of rHunks) rMap.set(h.baseStart, h);
            while (bi < bLines.length) {
                if (lMap.has(bi)) {
                    const h = lMap.get(bi);
                    for (let c = h.childStart; c < h.childEnd; c++) result.push(lLines[c]);
                    bi = h.baseEnd;
                } else if (rMap.has(bi)) {
                    const h = rMap.get(bi);
                    for (let c = h.childStart; c < h.childEnd; c++) result.push(rLines[c]);
                    bi = h.baseEnd;
                } else {
                    result.push(bLines[bi]);
                    bi++;
                }
            }
            // Append any trailing additions from local or remote
            for (const h of lHunks) {
                if (h.baseStart >= bLines.length) for (let c = h.childStart; c < h.childEnd; c++) result.push(lLines[c]);
            }
            for (const h of rHunks) {
                if (h.baseStart >= bLines.length) for (let c = h.childStart; c < h.childEnd; c++) result.push(rLines[c]);
            }
            return {merged: result.join('\n'), hasConflict: false};
        }
        // Conflict: produce annotated output with pre-indexed hunks for O(n)
        const lIdx = new Map();
        const rIdx = new Map();
        for (const h of lHunks) for (let k = h.baseStart; k < h.baseEnd; k++) lIdx.set(k, h);
        for (const h of rHunks) for (let k = h.baseStart; k < h.baseEnd; k++) rIdx.set(k, h);
        const out = [];
        let bi = 0;
        while (bi < bLines.length) {
            const lh = lIdx.get(bi);
            const rh = rIdx.get(bi);
            if (lh && rh) {
                out.push('<<<<<<< LOCAL');
                for (let c = lh.childStart; c < lh.childEnd; c++) out.push(lLines[c]);
                out.push('=======');
                for (let c = rh.childStart; c < rh.childEnd; c++) out.push(rLines[c]);
                out.push('>>>>>>> REMOTE');
                bi = Math.max(lh.baseEnd, rh.baseEnd);
            } else if (lh) {
                for (let c = lh.childStart; c < lh.childEnd; c++) out.push(lLines[c]);
                bi = lh.baseEnd;
            } else if (rh) {
                for (let c = rh.childStart; c < rh.childEnd; c++) out.push(rLines[c]);
                bi = rh.baseEnd;
            } else {
                out.push(bLines[bi]);
                bi++;
            }
        }
        return {merged: out.join('\n'), hasConflict: true};
    },
    // --- TOAST ---
    showToast(message, duration = 5000) {
        const el = document.getElementById('toast');
        el.textContent = message;
        el.classList.add('show');
        clearTimeout(this._toastTimer);
        this._toastTimer = setTimeout(() => el.classList.remove('show'), duration);
    },
    // --- CONFLICT / BACKUP HELPERS ---
    /**
     * Store backup content in IndexedDB so the user can retrieve it later
     * without blocking UI with a file picker dialog.
     */
    async _storeBackup(name, content) {
        if (!this.state.db) return false;
        try {
            const backupKey = name + '::backup::' + Date.now();
            const tx = this.state.db.transaction('handles', 'readwrite');
            await new Promise((resolve, reject) => {
                tx.onabort = () => reject(tx.error || new Error('Transaction aborted'));
                tx.onerror = () => reject(tx.error);
                const req = tx.objectStore('handles').put({type: 'backup', name, content, ts: Date.now()}, backupKey);
                req.onsuccess = () => resolve();
                req.onerror = () => reject(req.error);
            });
            return true;
        } catch (e) { return false; }
    },
    // --- SIDEBAR UI ---
    async removeHandle(e, name) {
        e.stopPropagation();
        if (!this.state.db) {
            console.error('Database not initialized');
            return;
        }
        if (confirm(`Remove shortcut for "${name}"? The file remains on your disk.`)) {
            const tx = this.state.db.transaction('handles', 'readwrite');
            await new Promise((resolve, reject) => {
                tx.onabort = () => reject(tx.error || new Error('Transaction aborted'));
                tx.onerror = () => reject(tx.error);
                const req = tx.objectStore('handles').delete(name);
                req.onsuccess = () => resolve();
                req.onerror = () => reject(req.error);
            });
            await this.deleteLockEntry(name);
            if (this.state.currentHandle?.name === name) {
                this.state.currentHandle = null;
                this.updateSaveButtonLabel();
                this.teardownLockPoller();
                document.getElementById('editor').value = '';
                document.getElementById('active-filename').textContent = 'No file selected';
            }
            await this.renderList();
        }
    },
    async renderList() {
        const list = document.getElementById('file-list');
        if (!this.state.db) {
            list.textContent = '';
            const p = document.createElement('p');
            p.style.color = 'var(--text-sub)';
            p.textContent = 'Local storage unavailable';
            list.appendChild(p);
            return;
        }
        list.textContent = '';
        try {
            const results = await this.getHandlesFromDB();
            const handles = results.filter(h => h && typeof h.kind === 'string' && typeof h.getFile === 'function');
            const sorted = handles.sort((a, b) => a.name.localeCompare(b.name));
            const fragment = document.createDocumentFragment();
            sorted.forEach(h => {
                const item = document.createElement('div');
                item.className = `file-item ${this.state.currentHandle?.name === h.name ? 'active' : ''}`;
                item.setAttribute('data-filename', h.name);
                item.setAttribute('tabindex', '0');
                item.setAttribute('role', 'button');
                item.setAttribute('aria-label', `Open file ${h.name}`);
                const nameSpan = document.createElement('span');
                nameSpan.style.overflow = 'hidden';
                nameSpan.style.textOverflow = 'ellipsis';
                // textContent is used here (not innerHTML) to prevent XSS
                nameSpan.textContent = h.name;
                const removeBtn = document.createElement('span');
                removeBtn.className = 'remove-btn';
                removeBtn.textContent = 'âœ•';
                removeBtn.setAttribute('aria-label', `Remove file ${h.name}`);
                removeBtn.setAttribute('role', 'button');
                item.appendChild(nameSpan);
                item.appendChild(removeBtn);
                fragment.appendChild(item);
            });
            list.appendChild(fragment);
            if (sorted.length === 0) {
                const p = document.createElement('p');
                p.style.color = 'var(--text-sub)';
                p.textContent = 'No files yet. Create one to start.';
                list.appendChild(p);
            }
        } catch (e) {
            list.textContent = '';
            const p = document.createElement('p');
            p.style.color = 'var(--danger)';
            p.textContent = 'Error loading file list';
            list.appendChild(p);
        }
    },
    async getDecryptedText(buffer) {
        if (buffer.byteLength === 0) {
            return {plainBytes: new Uint8Array(0), success: true};
        }
        if (buffer.byteLength < 1 + APP_CONFIG.SALT_LENGTH + APP_CONFIG.IV_LENGTH + APP_CONFIG.GCM_TAG_LENGTH) {
            return {errorMessage: '### DECRYPTION ERROR ###\nInvalid file format.', success: false};
        }
        if (buffer[0] !== APP_CONFIG.FILE_FORMAT_VERSION) {
            return {errorMessage: '### DECRYPTION ERROR ###\nUnsupported file format version.', success: false};
        }
        const salt = buffer.slice(1, 1 + APP_CONFIG.SALT_LENGTH);
        const saltArray = new Uint8Array(salt);
        let key;
        try {
            key = await this.deriveKeyFromSalt(saltArray);
        } catch (e) {
            return {errorMessage: '### DECRYPTION ERROR ###\nFailed to derive key.', success: false};
        }
        const iv = buffer.slice(1 + APP_CONFIG.SALT_LENGTH, 1 + APP_CONFIG.SALT_LENGTH + APP_CONFIG.IV_LENGTH);
        const ciphertext = buffer.slice(1 + APP_CONFIG.SALT_LENGTH + APP_CONFIG.IV_LENGTH);
        // Build metadata buffer [Version][Salt][IV] for GCM additional authenticated data
        const metadata = buffer.slice(0, 1 + APP_CONFIG.SALT_LENGTH + APP_CONFIG.IV_LENGTH);
        try {
            const plain = await crypto.subtle.decrypt({ name: "AES-GCM", iv, additionalData: metadata }, key, ciphertext);
            return {plainBytes: new Uint8Array(plain), success: true};
        } catch (e) {
            return {errorMessage: '### DECRYPTION ERROR ###\nUnable to decrypt file. Please verify your password is correct.', success: false};
        }
    }
};
const arraysEqual = (a, b) => {
    if (a.byteLength !== b.byteLength) return false;
    for (let i = 0; i < a.byteLength; i++) if (a[i] !== b[i]) return false;
    return true;
};
document.getElementById('app-version').textContent = `v${APP_CONFIG.VERSION}`;
App.init();
</script>
